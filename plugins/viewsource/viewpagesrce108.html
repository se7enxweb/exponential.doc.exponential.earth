                    
    
                    
    
                    
    
<!DOCTYPE html>
<html>
    
<!-- Mirrored from doc.ez.no/plugins/viewsource/viewpagesrc.action?pageId=31430767 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 31 Jan 2017 10:25:06 GMT -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>View Source</title>
        <link rel="canonical" href="../../pages/viewpagee108.html?pageId=31430767" />
        <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-rest:web-resource-manager.resource-base-url-pattern"]="\"(?:(?:/s/.*?/_)?/download)\"";
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\"\"";
WRM._unparsedData["com.atlassian.plugins.browser.metrics.browser-metrics-plugin:browser-metrics.feature-data-provider-legacy"]="true";
</script>
<link type="text/css" rel="stylesheet" href="../../s/1b9968ac17721e3a6947d14e3a43c3f8-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch9c16.css?build-number=5983" media="all">
<!--[if lt IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch.css?conditionalComment=lt+IE+9" media="all">
<![endif]-->
<!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch.css?conditionalComment=lte+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/f3685658010e413141854089096800b5/_/download/contextbatch/css/plugin.viewsource/batch.css" media="all">
<link type="text/css" rel="stylesheet" href="../../s/df762e50bc83a9608020a1ff1476cda6-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/5a0f37b8e5a58a48983bc1f25fb099f6/_/download/contextbatch/css/page/batch.css" media="all">
<!--[if lt IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/5a0f37b8e5a58a48983bc1f25fb099f6/_/download/contextbatch/css/page/batch.css?conditionalComment=lt+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/5714bd5a5c86641cad10106916cda7c8-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/49f5f7dfc888d48bff618d087d8044cc/_/download/contextbatch/css/editor-content/batch.css" media="all">
<!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/49f5f7dfc888d48bff618d087d8044cc/_/download/contextbatch/css/editor-content/batch.css?conditionalComment=lte+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/6/_/styles/colors74cd.css?spaceKey=DEVELOPER" media="all">
<link type="text/css" rel="stylesheet" href="../../s/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/6/_/styles/custom74cd.css?spaceKey=DEVELOPER" media="all">

    </head>

    <body class="mceContentBody aui-theme-default wiki-content fullsize">
        <p>&nbsp;</p>         <div class="contentLayout2">
<div class="columnLayout two-right-sidebar" data-layout="two-right-sidebar">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1>Field Type API &amp; best practices</h1><p>eZ Platform can support arbitrary data to be stored in the fields of a content item. In order to support custom data, besides the standard data types, a developer needs to create a custom <strong>Field Type</strong>.</p><p>The implementation of a custom Field Type is done based on the Field Type SPI and its interfaces. These can be found under <code>eZ\Publish\SPI\FieldType</code>.</p><p>In order to provide custom functionality for a Field Type, the SPI interacts with multiple layers of the eZ Platform architecture, as shown in the following diagram:</p><p> <img class="confluence-embedded-image" src="../../download/attachments/31430767/field_type_overview8c8d.png?version=1&amp;modificationDate=1461319209000&amp;api=v2" data-image-src="/download/attachments/31430767/field_type_overview.png?version=1&amp;modificationDate=1461319209000&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="31430766" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="field_type_overview.png" data-base-url="https://doc.ez.no" data-linked-resource-content-type="image/png" data-linked-resource-container-id="31430767" data-linked-resource-container-version="5" title="Developer > Field Type API and best practices > field_type_overview.png" data-location="Developer > Field Type API and best practices > field_type_overview.png" data-image-height="402" data-image-width="613"></p><p>On the top layer, the Field Type needs to provide conversion from and to a simple PHP hash value to support the REST API. The generated hash value may only consist of scalar values and hashes. It must not contain objects or arrays with numerical indexes that aren't sequential and/or don't start with zero.</p><p>Below that, the Field Type must support the Public API implementation (aka Business Layer), regarding:</p><ul><li>Settings definition for FieldDefinitions</li><li>Value creation and validation</li><li>Communication with the Persistence SPI</li></ul><p>On the bottom level, a Field Type can additionally hook into the Persistence SPI, in order to store data from a FieldValue in an external service. Note that all non-standard Exponential database tables (e.g. <code>ezurl</code>) are also considered &quot;external storage&quot; from now on.</p><p>The following sequence diagram visualizes the process of creating a new <code>Content</code> across all layers, especially focused on the interaction with a <code>FieldType</code>.</p><p><img class="confluence-embedded-image" width="900" src="../../download/attachments/31430767/create_content_sequencedd78.png?version=1&amp;modificationDate=1461319208000&amp;api=v2" data-image-src="/download/attachments/31430767/create_content_sequence.png?version=1&amp;modificationDate=1461319208000&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="31430764" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="create_content_sequence.png" data-base-url="https://doc.ez.no" data-linked-resource-content-type="image/png" data-linked-resource-container-id="31430767" data-linked-resource-container-version="5" title="Developer > Field Type API and best practices > create_content_sequence.png" data-location="Developer > Field Type API and best practices > create_content_sequence.png" data-image-height="677" data-image-width="1531"><br /> </p><p>In the next lines/pages, this document explains how to implement a custom Field Type based on the SPI and what is expected from it. As a code example, please refer to the Url FieldType, which has been implemented as a reference.</p><h2>Public API interaction</h2><p>The interaction with the Public API is done through the interface <code>eZ\Publish\SPI\FieldType\FieldType</code>. A custom Field Type must provide an implementation of this interface. In addition, it is considered best practice to provide a value object class for storing the custom field value provided by the Field Type.</p><h3>FieldDefinition handling</h3><p>In order to make use of a custom Field Type, the user must apply it in a <code>eZ\Publish\API\Repository\Values\ContentType\FieldDefinition</code> of a custom Content Type. The user may in addition provide settings for the Field Type and a validator configuration.  Since the Public API cannot know anything about these, their handling is delegated to the Field Type itself through the following methods:</p><p><code>getFieldTypeIdentifier()</code></p><p style="margin-left: 30.0px;">Returns a unique identifier for the custom Field Type, which is used to assign the type to a Field Definition. By convention for the returned type identifier string should be prefixed by a unique shortcut for the vendor (e.g. <code>ez</code> for eZ Systems).</p><p><code>getSettingsSchema()</code></p><p style="margin-left: 30.0px;">Using this method, the Public API retrieves a schema for the field type settings. A typical setting would e.g. be a default value. The settings structure defined by this schema is stored in the <code>FieldDefinition</code>. Since it is not possible to define a generic format for such a schema, the Field Type is free to return any serializable data structure from this method.</p><p><code>getValidatorConfigurationSchema()</code></p><p style="margin-left: 30.0px;">In addition to normal settings, the Field Type should provide a schema settings for it's validation process. The schema describes, what kind of validation can be performed by the Field Type and which settings the user can specify to these validation methods. For example, the <code>ezstring</code> type can validate minimum and maximum length of the string. It therefore provides a schema to indicate to the user that he might specify the corresponding restrictions, when creating a <code>FieldDefinition</code> with this type. Again, the schema does not underlie any regulations, except for that it must be serializable.</p><p><code>validateFieldSettings()</code></p><p style="margin-left: 30.0px;">Before the Public API stores settings for the <code>FieldType</code> in a <code>FieldDefinition</code>, the type is asked to validate the settings (which were provided by the user). As a result, the <code>FieldType</code> must return if the given settings comply to the schema defined by <code>getSettingsSchema()</code>. <code>validateValidatorConfiguration()</code> Analog to <code>validateFieldSettings()</code>, this method verifies that the given validator configuration complies to the schema provided by <code>getValidatorConfigurationSchema()</code>.</p><p>It is important to note that while the schema definitions of the <code>FieldType</code> maybe both be of arbitrary, serializable format, it is highly recommended to use a simple hash structure. It is highly recommended to follow the <a class="confluence-link" href="#FieldTypeAPIandbestpractices-Bestpractices" data-anchor="Bestpractices" data-linked-resource-default-alias="Bestpractices" data-base-url="../../index.html">Best practices</a> in order to create future proof schemas.</p><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="f00353dc-3ed5-4b09-80f6-91c336e2260c" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingd35c.png?definition=e2luZm99&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body"><p><strong>Note:</strong> Since it is not possible to enforce a schema format, the code using a specific <code>FieldType</code> must basically know all <code>FieldType</code>s it deals with.</p><p>This will also apply to all user interfaces and the REST API, which therefore must provide extension points to register handling code for custom <code>FieldType</code>. These extensions are not defined, yet.</p></td></tr></table><h4>Name of the Field Type</h4><p>If you implement Nameable as an extra service, and register this Service using the tag <code>nameable</code>, the method <code>{FieldType}Nameable-&gt;getFieldName()</code> will be used to retrieve the name.</p><p>Otherwise the regular <code>{FieldType}-&gt;getName()</code> method is used.</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="48c477fd-f35f-46cf-bb1e-87dd3475d161" data-macro-parameters="language=powershell|title=Example from fieldtype_services.yml " data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading5935.png?definition=e2NvZGU6bGFuZ3VhZ2U9cG93ZXJzaGVsbHx0aXRsZT1FeGFtcGxlIGZyb20gZmllbGR0eXBlX3NlcnZpY2VzLnltbCB9&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre># Nameable services (for fieldtypes that need advance name handling)
    exponential.fieldType.ezobjectrelation.nameable_field:
        class: %exponential.fieldType.ezobjectrelation.nameable_field.class%
        arguments:
          - @exponential.spi.persistence.cache.contentHandler
        tags:
            - {name: exponential.fieldType.nameable, alias: ezobjectrelation}</pre></td></tr></table><p> </p><h3>Value handling</h3><p>A field type needs to deal with the custom value format provided by it. In order for the public API to work properly, it delegates working with such custom field values to the corresponding Field Type. The <code>SPI\FieldType\FieldType</code> interface therefore provides the following methods:</p><p><code>acceptValue()</code></p><p style="margin-left: 30.0px;">This method is responsible for accepting and converting user input for the field. It checks the input structure it accepts and might build and return a different structure holding the data. An example would be, that the user just provides an HTTP link as a string, which is converted to the value object of the Url FieldType. Unlike the <code>FieldType\Value</code> constructor, it is perfectly acceptable to make this method aware of multiple input types (object or primitive, for instance).</p><p style="margin-left: 30.0px;">Note: The method must assert structural consistency of the value, but must not validate plausibility of the value.</p><p><code>getEmptyValue()</code></p><p style="margin-left: 30.0px;">Through settings, the <code>FieldType</code> can specify, that the user may define a default value for the <code>Field</code> of the type. If no such default is provided by the user, the <code>FieldType</code> itself is asked for an &quot;empty value&quot; as the final fallback. The value chain for a specific field is therefore like this, when a <code>Field</code> of the <code>FieldType</code> is filled out:</p><ol><li style="list-style-type: none;"><ol><li>Is a value provided by the filling user?</li><li>Is a default provided by the <code>FieldDefinition</code>?</li><li>Take the empty value provided by the <code>FieldType</code></li></ol></li></ol><p><code>validate()</code></p><p style="margin-left: 30.0px;">In contrast to <code>acceptValue()</code> this method validates the plausibility of the given value, based on the <code>FieldType</code> settings and validator configuration, stored in the corresponding <code>FieldDefinition</code>.</p><div class="section"><h3><span style="font-size: 1.4em;">Storage conversion</span></h3></div><div class="section"><p>As said above, the value format of a <code>FieldType</code> is free form. However, in order to make Exponential store the value in it's database, it must comply to certain rules at storage time. To not restrict the value itself, a <code>FieldValue</code> must be converted to the storage specific format used by the Persistence SPI: <code>eZ\Publish\SPI\Persistence\Content\FieldValue</code>. After restoring a Field of <code>FieldType</code>, the conversion must be undone. The following methods of the <code>FieldType</code> are responsible for that:</p><p><code>toPersistenceValue()</code></p><p style="margin-left: 30.0px;">This method receives the value of a <code>Field</code> of <code>FieldType</code> and must return an SPI <code>FieldValue</code>, which can be stored.</p><p><code>fromPersistenceValue()</code></p><p style="margin-left: 30.0px;">As the counterpart, this method receives an SPI <code>FieldValue</code> and must reconstruct the original value of the <code>Field</code> from it.</p><p>The SPI FieldValue struct has several properties, which might be used by the FieldType as follows:</p><p><code>$data</code></p><p style="margin-left: 30.0px;">The data to be stored in the Exponential database. This may either be a scalar value, a hash map or a simple, serializable object.</p><p><code>$externalData</code></p><p style="margin-left: 30.0px;">The arbitrary data stored in this field will not be touched by any of the Exponential components directly, but will be hold available for <a class="confluence-link" href="#FieldTypeAPIandbestpractices-Storingexternaldata" data-anchor="Storingexternaldata" data-linked-resource-default-alias="Storingexternaldata" data-base-url="../../index.html">Storing external data</a>.</p><p><code>$sortKey</code></p><p style="margin-left: 30.0px;">An value which can be used to sort <code>Content</code> by the field.</p><div class="note"><p class="last" style="margin-left: 30.0px;"><em>Note: TBD: Where will you register the Indexable implementations?</em></p></div></div><div class="section"><h2>Searching</h2><p>Fields, or a custom field type, might contain or maintain data which is relevant for user searches. To make the search engine aware of the data in your field type you need to implement an additional interface and register the implementation.</p><p>If your field type does not maintain any data, which should be available to search engines, feel free to just ignore this section.</p><p>The<code> eZ\Publish\SPI\FieldType\Indexable</code> defines two methods, which are required to be implemented, if the field type provides data relevant to search engines. The interface defines two methods for this:</p><p><code>getIndexData( Field $field )</code></p><p style="margin-left: 30.0px;">This method is supposed to return the actual index data for the provided <code>eZ\Publish\SPI\Persistence\Content\Field</code>. The index data consists of an array of <code>eZ\Publish\SPI\Persistence\Content\Search\Field</code> instances. They are described below in further detail.</p><p><code>getIndexDefinition()</code></p><p style="margin-left: 30.0px;">To be able to query data properly an indexable field type also is required to return search specification. You must return a hash map of <code>eZ\Publish\SPI\Persistence\Content\Search\FieldType</code> instances from this method, which could look like:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="5c3d7333-7f71-440b-bc7b-e54b45cefc35" data-macro-parameters="language=php" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading1802.png?definition=e2NvZGU6bGFuZ3VhZ2U9cGhwfQ&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>array(
    'url'  => new Search\FieldType\StringField(),
    'text' => new Search\FieldType\StringField(),
)</pre></td></tr></table><p style="margin-left: 30.0px;"> This example from the <code>Url</code> field type shows that the field type will always return two indexable values, both strings. They have the names <code>url</code> and <code>text</code> respectively.</p><div class="section"><h3>Search Field Values</h3><p>The search field values, returned by the <code>getIndexData</code> method are simple value objects consisting of the following properties:</p><p><code>$name</code></p><p style="margin-left: 30.0px;">The name of the field</p><p><code>$value</code></p><p style="margin-left: 30.0px;">The value of the field</p><p><code>$type</code></p><p style="margin-left: 30.0px;">An <code>eZ\Publish\SPI\Persistence\Content\Search\FieldType</code> instance, describing the type information of the field.</p></div><div class="section"><h3>Search Field Types</h3><p>There are bunch of available search field types, which are automagically handled by our Search backend configuration. When using those there is no requirement to adapt , for example, the Solr configuration in any way. You can always use custom field types, though, but these might require re-configuration of the search backend. For Solr this would mean adapting the schema.xml.</p><p>The default available search field types are:</p><p><code>StringField.php</code></p><p style="margin-left: 30.0px;">Standard string values. Will also be queries by full text searches.</p><p><code>TextField.php</code></p><p style="margin-left: 30.0px;">Standard text values. Will be queried by full text searches. Configured text normalizations in the search backend apply.</p><p><code>BooleanField.php</code></p><p style="margin-left: 30.0px;">Boolean values.</p><p><code>DateField.php</code></p><p style="margin-left: 30.0px;">Date field. Can be used for date range queries.</p><p><code>FloatField.php</code></p><p style="margin-left: 30.0px;">Field for floating point numbers.</p><p><code>IntegerField.php</code></p><p style="margin-left: 30.0px;">Field for integer numbers.</p><p><code>PriceField.php</code></p><p style="margin-left: 30.0px;">Field for price values. Currency conversion might be applied by the search backends. Might require careful configuration.</p><p><code>IdentifierField.php</code></p><p style="margin-left: 30.0px;">Field used for IDs. Basically acts like the string field, but will not be queried by fulltext searches</p><p><code>CustomField.php</code></p><p style="margin-left: 30.0px;">Custom field, for custom search data types. Will probably require additional configuration in the search backend.</p></div><div class="section"><h3>Configuring Solr</h3><p>As mentioned before, if you are using the standard type definitions <strong>there is no need to configure the search backend in any way</strong>. Everything will work fine. The field definitions are handled using <code>dynamicField</code> definitions in Solr, for example.</p><p>If you want to configure the handling of your field, you can always add a special field definition the Solr <code>schema.xml</code>. The field type names, which are used by the Solr search backend look like this for fields: <code><span class="pre">&lt;content_type_identifier&gt;/&lt;field_identifier&gt;/&lt;search_field_name&gt;_&lt;type&gt;</span></code>. You can, of course define custom <code>dynamicField</code> definitions to match, for example, on your custom <code>_&lt;type&gt;</code> definition.</p><p>You could also define a custom field definition dedicatedly for certain fields, like for the name field in an article:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8bb28c36-b7e4-4ec2-8bde-eceaae0c8b06" data-macro-parameters="language=html/xml" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading26b2.png?definition=e2NvZGU6bGFuZ3VhZ2U9aHRtbC94bWx9&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>&lt;field name="article/name/value_s" type="string" indexed="true" stored="true" required="false"/></pre></td></tr></table><p>If you want to learn more about the Solr implementation and detailed information about configuring it, check out the <a class="confluence-link" href="../../login6609.html?pageId=30711228" data-linked-resource-id="30711228" data-linked-resource-version="1" data-linked-resource-type="page" data-linked-resource-default-alias="Solr Search Service Implementation Notes" data-base-url="../../index.html">Solr Search Service Implementation Notes</a>.</p></div></div><div class="section"><h2>Storing external data</h2><p>A <code>FieldType</code> may store arbitrary data in external data sources and is in fact encouraged to do so. External storages can be e.g. a web service, a file in the file system, another database or even the Exponential database itself (in form of a non-standard table). In order to perform this task, the <code>FieldType</code> will interact with the Persistence SPI, which can be found in <code>eZ\Publish\SPI\Persistence</code>, through the <code>eZ\Publish\SPI\FieldType\FieldStorage</code> interface.</p><p>Whenever the internal storage of a Content item that includes a Field of the <code>FieldType</code> is accessed, one of the following methods is called to also access the external data:</p><p><code>hasFieldData()</code></p><p style="margin-left: 30.0px;">Returns if the <code>FieldType</code> stores extrnal data at all.</p><p><code>storeFieldData()</code></p><p style="margin-left: 30.0px;">Called right before a <code>Field</code> of <code>FieldType</code> is stored. The method should perform the storing of <code>$externalData</code>. The method must return <code>true</code>, if the call manipulated <strong>internal data</strong> of the given <code>Field</code>, so that it is updated in the internal database.</p><p><code>getFieldData()</code></p><p style="margin-left: 30.0px;">Is called after a <code>Field</code> has been restored from the database in order to restore <code>$externalData</code>.</p><p><code>deleteFieldData()</code></p><p style="margin-left: 30.0px;">Must delete external data for the given <code>Field</code>, if exists.</p><p><code>getIndexData()</code></p><p style="margin-left: 30.0px;">See search service</p><p>Each of the above methods receive a $context array, which contains information on the underlying storage and the environment. This context can be used to store data in the Exponential data storage, but outside of the normal structures (e.g. a custom table in an SQL database). Note that the Field Type must take care on it's own for being compliant to different data sources and that 3rd parties can extend the data source support easily. For more information about this, take a look at the <a class="confluence-link" href="#FieldTypeAPIandbestpractices-Bestpractices" data-anchor="Bestpractices" data-linked-resource-default-alias="Bestpractices" data-base-url="../../index.html">Best practices</a><a class="reference internal" /> section.</p></div><div class="section"><h2>Legacy Storage conversion</h2><p>The <code>FieldType</code> system is designed for future storage back ends of Exponential. However, the old database schema (<em>Legacy Storage</em>) must still be supported. Since this database cannot store arbitrary value information as provided by a <code>FieldType</code>, another conversion step must take place if the Legacy Storage is used.</p><p>The conversion takes place through the interface <code>eZ\Publish\Core\Persistence\Legacy\Content\FieldValue\Converter</code>, which you must provide an implementation of with your <code>FieldType</code>. The following methods are contained in the interface:</p><p><code>toStorageValue()</code></p><p style="margin-left: 30.0px;">Converts a Persistence <code>Value</code> into a legacy storage specific value.</p><p><code>fromStorageValue()</code></p><p style="margin-left: 30.0px;">Converts the other way around.</p><p><code>toStorageFieldDefinition()</code></p><p style="margin-left: 30.0px;">Converts a Persistence <code>FieldDefinition</code> to a storage specific one.</p><p><code>fromStorageFieldDefinition</code></p><p style="margin-left: 30.0px;">Converts the other way around.</p><p><code>getIndexColumn()</code></p><p style="margin-left: 30.0px;">Returns the storage column which is used for indexing.</p><div class="section"><h3>Registering a converter</h3><p>The registration of a <code>Converter</code> currently works through the <code>$config</code> parameter of <code>eZ\Publish\Core\Persistence\Legacy\Handler</code>. See the class documentation for further details.</p><div class="note"><p> </p><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="d1b8ee4d-998a-4726-a083-6a8cd36c8831" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingd35c.png?definition=e2luZm99&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body">For global service container integration, see <a class="confluence-link" href="../../display/DEVELOPER/Register%2bField%2bType.html" data-linked-resource-id="31430769" data-linked-resource-version="2" data-linked-resource-type="page" data-linked-resource-default-alias="Register Field Type" data-base-url="../../index.html">Register Field Type</a>.</td></tr></table><h2>REST API interaction</h2><p>When REST API is used, conversion needs to be done for <code>FieldType</code> values, settings and validator configurations. These are converted to and from a simple hash format that can be encoded in REST payload (typically XML or JSON). As conversion needs to be done both when transmitting and receiving data through REST, <code>FieldType</code> implements following pairs of methods:</p><p><code>toHash()</code></p><p style="margin-left: 30.0px;">Converts FieldType Value into a plain hash format.</p><p><code>fromHash()</code></p><p style="margin-left: 30.0px;">Converts the other way around.</p><p><code>fieldSettingsToHash()</code></p><p style="margin-left: 30.0px;">Converts FieldType settings to a simple hash format.</p><p><code>fieldSettingsFromHash()</code></p><p style="margin-left: 30.0px;">Converts the other way around.</p><p><code>validatorConfigurationToHash()</code></p><p style="margin-left: 30.0px;">Converts FieldType validator configuration to a simple hash format.</p><p><code>validatorConfigurationFromHash()</code></p><p style="margin-left: 30.0px;">Converts the other way around.</p><h3>Extension points</h3><p>Some <code>FieldTypes</code> will require additional processing, for example a <code>FieldType</code> storing a binary file, or one having more complex settings or validator configuration. For this purpose specific implementations of an abstract class <code>eZ\Publish\Core\REST\Common\FieldTypeProcessor</code> are used. This class provides following methods:</p><p><code>preProcessValueHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a received value hash, so that it conforms to the format expected by the <code>fromHash()</code> method described above.</p><p><code>postProcessValueHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a outgoing value hash, previously generated by the <code>toHash()</code> method described above.</p><p><code>preProcessFieldSettingsHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a received settings hash, so that it conforms to the format expected by the <code>fieldSettingsFromHash()</code> method described above.</p><p><code>postProcessFieldSettingsHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a outgoing settings hash, previously generated by the <code>fieldSettingsToHash()</code> method described above.</p><p><code>preProcessValidatorConfigurationHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a received validator configuration hash, so that it conforms to the format expected by the <code>validatorConfigurationFromHash()</code> method described above.</p><p><code>postProcessValidatorConfigurationHash()</code></p><p style="margin-left: 30.0px;">Performs manipulations on a outgoing validator configuration hash, previously generated by the <code>validatorConfigurationToHash()</code> method described above.</p><p>Base implementations of these methods simply return the given hash, so you can implement only the methods your <code>FieldType</code> requires. Some <code>FieldTypes</code> coming with the Exponential installation already implement processors and you are encouraged to take a look at them.</p><p>For details on registering a <code>FieldType</code> processor, see <a class="confluence-link" href="../../display/DEVELOPER/Register%2bField%2bType.html" data-linked-resource-id="31430769" data-linked-resource-version="2" data-linked-resource-type="page" data-linked-resource-default-alias="Register Field Type" data-base-url="../../index.html">Register Field Type</a>.</p></div></div></div><div class="section"><h2>Best practices</h2><p>In this chapter, best practices for implementing a custom <cite>FieldType</cite> are collected. We highly encourage following these practices to be future proof.</p><div class="section"><h3>Gateway based Storage</h3><p>In order to allow the usage of a <code>FieldType</code> that uses external data with different data storages, it is recommended to implement a gateway infrastructure and a registry for the gateways. In order to ease this action, the Core implementation of <code>FieldType</code> s provides corresponding interfaces and base classes. These can also be used for custom field types.</p><p>The interface <code>eZ\Publish\Core\FieldType\StorageGateway</code> is implemented by gateways, in order to be handled correctly by the registry. It has only a single method:</p><p><code>setConnection()</code></p><p style="margin-left: 30.0px;">The registry mechanism uses this method to set the SPI storage connection (e.g. the database connection to the Legacy Storage database) into the gateway, which might be used to store external data. The connection is retrieved from the <code>$context</code> array  automatically by the registry.</p><p>Note that the Gateway implementation itself must take care about validating that it received a usable connection. If it did not, it should throw a <code>RuntimeException</code>.</p><p>The registry mechanism is realized as a base class for <code>FieldStorage</code> implementations: <code>eZ\Publish\Core\FieldType\GatewayBasedStorage</code>. For managing <code>StorageGateway</code> s, the following methods are already implemented in the base class:</p><p><code>addGateway()</code></p><p style="margin-left: 30.0px;">Allows the registration of additional <code>StorageGateway</code>s from the outside. Furthermore, a hash map of <code>StorageGateway</code>s can be given to the constructor for basic initialization. This array should orginate from the Dependency Injection mechanism.</p><p><code>getGateway()</code></p><p style="margin-left: 30.0px;">This protected method is used by the implementation to retrieve the correct <code>StorageGateway</code> for the current context.</p><p>As a reference for the usage of these infrastructure, the Keyword, Url and User types can be examined.</p></div><div class="section"><h3>Settings schema</h3><p>It is recommended to use a simple hash map format for the settings schema retured by <span class="pre">eZ\Publish\SPI\FieldType\FieldType::getSettingsSchema()</span>, which follows these rules:</p><ul class="simple"><li>The key of the hash map identifies a setting (e.g. <code>default</code>)</li><li>Its value is a hash map (2nd level) describing the setting using<br /><ul><li><code>type</code> to identify the setting type (e.g. <code>int</code> or <code>string</code>)</li><li><code>default</code> containing the default setting value</li></ul></li></ul><p>An example schema could look like this:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="94e60e7c-933b-42a7-a87a-bc5cbf6ea509" data-macro-parameters="language=php" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading1802.png?definition=e2NvZGU6bGFuZ3VhZ2U9cGhwfQ&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>array(
    'backupData' => array(
        'type' => 'bool',
        'default' => false
    ),
    'defaultValue' => array(
        'type' => 'string',
        'default' => 'Sindelfingen'
    )
);</pre></td></tr></table><p> </p></div><div class="section"><h3>Validator schema</h3><p>The schema for validator configuration should have a similar format than the settings schema has, except it has an additional level, to group settings for a certain validation mechanism:</p><ul class="simple"><li>The key on the 1st level is a string, identifying a validator</li><li>Assigned to that is a hash map (2nd level) of settings</li><li>This hash map has a string key for each setting of the validator</li><li>It is assigned to a 3rd level hashmap, the setting description</li><li>This hash map should have the same format as for normal settings</li></ul><p>For example, for the <code>ezstring</code> type, the validator schema could be:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="1fec65af-6435-412a-b7f1-3806eca40ae0" data-macro-parameters="language=php" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading1802.png?definition=e2NvZGU6bGFuZ3VhZ2U9cGhwfQ&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>array(
    'stringLength' => array(
        'minStringLength' => array(
            'type'    => 'int',
            'default' => 0,
        ),
        'maxStringLength' => array(
            'type'    => 'int'
            'default' => null,
        )
    ),
);</pre></td></tr></table><h2>Registering a Field Type</h2><p>To register a Field Type, see <a class="confluence-link" href="../../display/DEVELOPER/Register%2bField%2bType.html" data-linked-resource-id="31430769" data-linked-resource-version="2" data-linked-resource-type="page" data-linked-resource-default-alias="Register Field Type" data-base-url="../../index.html">Register Field Type</a>.</p><p>To be integrated in unit and integration tests, Field Types need to be registered through the <code>service.ini</code> in <code>eZ/Publish/Core/settings</code>.</p><h2>Templating</h2><p>A FieldType always need a piece of template to be correctly displayed. See <a class="confluence-link" href="../../display/DEVELOPER/Field%2bType%2btemplate.html" data-linked-resource-id="31430773" data-linked-resource-version="2" data-linked-resource-type="page" data-linked-resource-default-alias="Field Type template" data-base-url="../../index.html">Field Type template</a>.</p></div></div><h2>Testing</h2><p><code>FieldType</code> s should be integration tested on 1 different levels:</p><ol class="arabic simple"><li>Their integration with the Persistence SPI</li><li>Their integration with the Public API</li></ol><p>For both test environments, infrastructure is already in place, so that you can easily implement the required tests for your custom <code>FieldType</code></p><div class="section"><h3>Persistence SPI</h3><p>This type of integration test ensures, that a Field Type stores its data properly on basis of different Persistence SPI implementations.</p><div class="note"><p> </p><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="3b9e46c2-ee33-4c9d-82c1-c94787f9420e" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingd35c.png?definition=e2luZm99&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body"><strong>Note:</strong> By now, only the Legacy Storage implementation exists.</td></tr></table><p> </p></div><p>The integration tests with the Persistence SPI can be found in <code>eZ\Publish\SPI\Tests\FieldType</code>. In order to implement a test for your custom <code>FieldType</code>, you need to extend the common base class <code>eZ\Publish\SPI\Tests\FieldType\BaseIntegrationTest</code> and implement it's abstract methods. As a reference the <code>KeywordIntegrationTest</code>, <code>UrlIntegrationTest</code> and <code>UserIntegrationTest</code> can deal.</p><p>Running the test is fairly simple: Just specify the global <code>phpunit.xml</code> for PHPUnit configuration and make it execute a single test or a directory of tests, for example:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="44c89d1e-884f-4a00-8017-be48837a5fcc" data-macro-parameters="language=bash" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading174f.png?definition=e2NvZGU6bGFuZ3VhZ2U9YmFzaH0&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>$ phpunit -c phpunit.xml eZ/Publish/SPI/Tests/FieldType</pre></td></tr></table><p>in order to run all <code>FieldType</code> tests.</p></div><h3>Public API</h3><p>On a second level, the interaction between an implementation of the Public API (aka the Business Layer) and the Field Type is tested. Again, there is a common base class as the infrastructural basis for such tests, which resides in <code>eZ\Publish\API\Repository\Tests\FieldType\BaseIntegrationTest</code>.</p><div class="note"><p> </p><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="7e8cca33-f0c5-490e-87e7-87c29be61181" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingd35c.png?definition=e2luZm99&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body"><p>Note that the In-Memory stubs for the Public API integration test suite, do not perform actual Field Type calls, but mainly emulate the behavior of a Field Type for simplicity reasons.</p><p>If your Field Type needs to convert data between <code>storeFieldData()</code> and <code>getFieldData()</code>, you need to implement a <code>eZ\Publish\API\Repository\Tests\Stubs\PseudoExternalStorage</code> in addition, which performs this task. Running the tests against the Business Layer implementation of the Public API is not affected by this.</p></td></tr></table><p> </p></div><dl /><dl /><p> </p></div>
</div>
<div class="cell aside" data-type="aside">
<div class="innerCell">
<h4>In this topic:</h4><p><img class="editor-inline-macro" src="../servlet/confluence/placeholder/macro7c73.png?definition=e3RvYzptYXhMZXZlbD0zfQ&amp;locale=en_GB&amp;version=2" data-macro-name="toc" data-macro-id="b5b50c2f-ff6b-43d1-87c8-771b11b5959a" data-macro-parameters="maxLevel=3" data-macro-schema-version="1"></p></div>
</div>
</div>
</div>
        <p>&nbsp;</p>
    </body>

<!-- Mirrored from doc.ez.no/plugins/viewsource/viewpagesrc.action?pageId=31430767 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 31 Jan 2017 10:25:07 GMT -->
</html>
