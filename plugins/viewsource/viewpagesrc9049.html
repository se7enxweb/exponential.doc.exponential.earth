                    
    
                    
    
                    
    
<!DOCTYPE html>
<html>
    
<!-- Mirrored from doc.ez.no/plugins/viewsource/viewpagesrc.action?pageId=3506264 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 31 Jan 2017 10:41:23 GMT -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>View Source</title>
        <link rel="canonical" href="../../pages/viewpage9049.html?pageId=3506264" />
        <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-rest:web-resource-manager.resource-base-url-pattern"]="\"(?:(?:/s/.*?/_)?/download)\"";
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\"\"";
WRM._unparsedData["com.atlassian.plugins.browser.metrics.browser-metrics-plugin:browser-metrics.feature-data-provider-legacy"]="true";
</script>
<link type="text/css" rel="stylesheet" href="../../s/1b9968ac17721e3a6947d14e3a43c3f8-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch9c16.css?build-number=5983" media="all">
<!--[if lt IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch.css?conditionalComment=lt+IE+9" media="all">
<![endif]-->
<!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/89/_/download/superbatch/css/batch.css?conditionalComment=lte+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/f3685658010e413141854089096800b5/_/download/contextbatch/css/plugin.viewsource/batch.css" media="all">
<link type="text/css" rel="stylesheet" href="../../s/df762e50bc83a9608020a1ff1476cda6-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/5a0f37b8e5a58a48983bc1f25fb099f6/_/download/contextbatch/css/page/batch.css" media="all">
<!--[if lt IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/5a0f37b8e5a58a48983bc1f25fb099f6/_/download/contextbatch/css/page/batch.css?conditionalComment=lt+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/5714bd5a5c86641cad10106916cda7c8-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/49f5f7dfc888d48bff618d087d8044cc/_/download/contextbatch/css/editor-content/batch.css" media="all">
<!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="/s/d41d8cd98f00b204e9800998ecf8427e-CDN/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/49f5f7dfc888d48bff618d087d8044cc/_/download/contextbatch/css/editor-content/batch.css?conditionalComment=lte+IE+9" media="all">
<![endif]-->
<link type="text/css" rel="stylesheet" href="../../s/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/51/_/styles/colorsb538.css?spaceKey=EZP" media="all">
<link type="text/css" rel="stylesheet" href="../../s/en_GB/5983/f3e491afc761ac0a6981cfa3dcbc04fc7e88c149.16/51/_/styles/customb538.css?spaceKey=EZP" media="all">

    </head>

    <body class="mceContentBody aui-theme-default wiki-content fullsize">
        <p>&nbsp;</p>         <p><img class="editor-inline-macro" src="../servlet/confluence/placeholder/macro4170.png?definition=e3RvY30&amp;locale=en_GB&amp;version=2" data-macro-name="toc" data-macro-id="34a8fa91-b49e-4509-a381-f4967e972b98" data-macro-schema-version="1"></p><p>The Signal-Slot system provides a means for realizing loosely coupled dependencies in the sense that a code entity A can react on an event occurring in code entity B, without A and B knowing each other directly. This works by dispatching event information through a central third instance, the so called dispatcher:</p><p><img class="confluence-embedded-image confluence-content-image-border image-center" height="337" width="702" src="../../download/attachments/3506264/schematics8f2f.png?version=1&amp;modificationDate=1349888212000&amp;api=v2" data-image-src="/download/attachments/3506264/schematics.png?version=1&amp;modificationDate=1349888212000&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="5308417" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="schematics.png" data-base-url="https://doc.ez.no" data-linked-resource-content-type="image/png" data-linked-resource-container-id="3506264" data-linked-resource-container-version="13" title="Exponential 5.x > Signal-Slot > schematics.png" data-location="Exponential 5.x > Signal-Slot > schematics.png" data-image-height="337" data-image-width="702"></p><p>In the shown schematics, object B and one other object are interested in a certain signal. B is a so-called Slot that can be announced to be interested in receiving a Signal (indicated by the circular connector to the dispatcher). Object A now sends the corresponding Signal. The Dispatcher takes care of realizing the dependency and informs the Slot A (and one other Slot) about the occurrence of the Signal.</p><p>Signals roughly equal events, while Slots roughly equal event handlers. An arbitrary number (0â€¦n) of Slots can listen for a specific Signal. Every object that receives the Dispatcher as a dependency can send signals. However, the following conditions apply (that typically do not apply to event handling systems):</p><ul><li>A Slot cannot return anything to the object that issued a signal</li><li>It is not possible for a Slot to stop the propagation of a Signal, i.e. all listening Slots will eventually receive the Signal</li></ul><p>Those two conditions allow the asynchronous processing of Slots. That means: It is possible to determine, by configuration, that a Slot must not receive a Signal in the very same moment it occurs, but to receive it on a later point in time, maybe after other Signals from a queue have been processed or even on a completely different server.</p><h1>Signal</h1><p>A Signal represents a specific event, e.g. that a content version has been published. It consists of information that is significant to the event, e.g. the content ID and version number. Therefore, a Signal is represented by an object of a class that is specific to the Signal and that extends from <code>eZ\Publish\Core\SignalSlot\Signal</code>. The full qualified name of the Signal class is used to uniquely identify the Signal. For example, the class <code>eZ\Publish\Core\SignalSlot\Signal\ContentService\PublishVersionSignal</code> identifies the example Signal.</p><p>In order to work properly with asynchronous processing, Signals must not consist of any logic and must not contain complex data structures (such as further objects and resources). Instead, they must be exportable using the <code>__set_state()</code> method, so that it is possible to transfer a Signal to a different system.</p><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="da356c50-e79d-465b-90c2-0875b8ebfa41" data-macro-parameters="title=Note" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingb7a0.png?definition=e2luZm86dGl0bGU9Tm90ZX0&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body">Signals can theoretically be sent by any object that gets hold of a SignalDispatcher (<code>eZ\Publish\Core\SignalSlot\SignalDispatcher</code>). However, at a first stage, <strong>Signals are only sent by special implementations of the Public API to indicate core events</strong>. These services must and will be used by default and will wrap the original service implementations.</td></tr></table><h1>Slot</h1><p>A Slot extends the system by realizing functionality that is executed when a certain Signal occurs. To implement a Slot, you must create a class that derives from <code>eZ\Publish\Core\SignalSlot\Slot</code>. The full qualified name of the Slot class is also used as the unique identifier of the Slot. The Slot base class requires you to implement the single method <code>receive()</code>. When your Slot is configured to listen to a certain Signal and this Signal occurs, the <code>receive()</code> method of your Slot is called.</p><p>Inside the <code>receive()</code> method of your Slot you can basically realize any kind of logic. However, it is recommended that you only dispatch the action to be triggered to a dedicated object. This allows you to trigger the same action from within multiple Slots and to re-use the implementation from a completely different context.</p><p>Note that, due to the nature of Signal-Slot, the following requirements must be fulfilled by your Slot implementation:</p><ul><li>A Slot must not return anything to the Signal issuer</li><li>A Slot must be aware that it is potentially executed delayed or even on a different server</li></ul><p style="margin-left: 30.0px;"><strong>Important</strong>: A single Slot should not take care of processing more than one Signal. Instead, if you need to trigger same or similar actions as different Signals occur. you should encapsulate these actions into a dedicated class, of which your Slots receive an instance to trigger this action.</p><h1>Example: Updating URL aliases</h1><p>Updating URL aliases is a typical process that can be realized through a Signal-Slot extension for different reasons:</p><ul><li>The action must be triggered on basis of different events (e.g. content update, location move, etc.)</li><li>Direct implementation would involve complex dependencies between otherwise unrelated services</li><li>The action is not critical to be executed immediately, but can be made asynchronous, if necessary</li></ul><p>As a first step it needs to be determined for which Signals we need to listen in order to update URL aliases. Some of them are:</p><ul><li><code>eZ\Publish\Core\SignalSlot\Signal\ContentService\PublishVersionSignal</code></li><li><code>eZ\Publish\Core\SignalSlot\Signal\LocationService\CopySubtreeSignal</code></li><li><code>eZ\Publish\Core\SignalSlot\Signal\LocationService\MoveSubtreeSignal</code></li><li>â€¦</li></ul><p>There are of course additional Signals that trigger an update of URL aliases, but these are left out for simplicity here.</p><p>Now that we identified some Signals to react upon, we can start implementing Slots for these signals. For the first Signal, which is issued as soon as a new version of Content is published, there exists a method in <code>eZ\Publish\SPI\Persistence\Content\UrlAlias\Handler</code> for exactly that purpose: <code>publishUrlAliasForLocation()</code>. The Signal contains the ID of the content item and its newly published version number. Using this information, the corresponding Slot can fulfill its purposes with the following steps:</p><ol><li>Load the corresponding content and its locations</li><li>Call the URL alias creation method for each location</li></ol><p>To achieve this, the Slot has 2 dependencies:</p><ul><li><code>eZ\Publish\SPI\Persistence\Content\Handler</code><br />to load the content itself in order to retrieve the names</li><li><code>eZ\Publish\SPI\Persistence\Content\Location\Handler</code><br />to load the locations</li><li><p><code>eZ\Publish\SPI\Persistence\Content\UrlAlias\Handler</code><br />to create the aliases for each location</p></li></ul><p>So, a stub for the implementation could look like this:</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="413280a4-74e7-4ffd-b5e9-4b38dfd3e68a" data-macro-parameters="language=php" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-heading1802.png?definition=e2NvZGU6bGFuZ3VhZ2U9cGhwfQ&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tr><td class="wysiwyg-macro-body"><pre>namespace Acme\TestBundle\Slot;

use eZ\Publish\Core\SignalSlot\Slot as BaseSlot;
use eZ\Publish\API\Repository\Repository;
use eZ\Publish\SignalSlot\Signal;

class CreateUrlAliasesOnPublishSlot extends BaseSlot
{
    /**
     * @var \eZ\Publish\API\Repository\Repository
     */
    private $repository;
Â Â Â  public function __construct( Repository $repository )
Â Â Â  {
Â Â Â Â Â Â Â  $this->repository = $repository;
Â Â Â  }

Â Â Â  public function receive( Signal $signal )
Â Â Â  {
Â Â Â Â Â Â Â  if ( !$signal instanceof Signal\ContentService\PublishVersionSignal )
Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â  return;
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  // Load content
Â Â Â Â Â Â Â  // Load locations
Â Â Â Â Â Â Â  // Create URL aliases
Â Â Â  }
}</pre></td></tr></table><table class="wysiwyg-macro" data-macro-name="info" data-macro-id="36a3d29b-5899-447a-96fc-b465a0fe4a8d" data-macro-schema-version="1" style="background-image: url(../servlet/confluence/placeholder/macro-headingd35c.png?definition=e2luZm99&amp;locale=en_GB&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="RICH_TEXT"><tr><td class="wysiwyg-macro-body"><p>In order to make the newly created Slot react on the corresponding Signal, the following steps must be performed:</p><ol><li>Make the Slot available through the Symfony service container as a service</li><li>Register the Slot to react to the Signal of type <code>eZ\Publish\Core\SignalSlot\Signal\ContentService\PublishVersionSignal</code></li></ol><div><span style="font-family: monospace;">See <a class="confluence-link" href="../../display/EZP/How%2bto%2blisten%2bto%2bCore%2bevents.html" data-linked-resource-id="14123362" data-linked-resource-version="7" data-linked-resource-type="page" data-linked-resource-default-alias="How to listen to Core events" data-base-url="../../index.html">How to listen to Core events</a> recipe in the developer cookbook for more information.</span></div></td></tr></table>
        <p>&nbsp;</p>
    </body>

<!-- Mirrored from doc.ez.no/plugins/viewsource/viewpagesrc.action?pageId=3506264 by HTTrack Website Copier/3.x [XR&CO'2013], Tue, 31 Jan 2017 10:41:24 GMT -->
</html>
